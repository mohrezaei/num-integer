use Integer;

/// Provides methods to compute functions related to powers of 10.
pub trait Power10: Integer {

    /// Returns `true` if the number is a power of 10.
    ///
    /// # Examples
    ///
    /// ~~~
    /// use num_integer::Power10;
    /// assert_eq!(100u32.is_power_of_ten(), true);
    /// assert_eq!(4u32.is_power_of_ten(), false);
    /// ~~~
    fn is_power_of_ten(&self) -> bool;

    /// Returns the base 10 logarithm value, truncated down.
    ///
    /// # Examples
    ///
    /// ~~~
    /// use num_integer::Power10;
    /// assert_eq!(100u32.floor_log10(), 2);
    /// assert_eq!(4u32.floor_log10(), 0);
    /// ~~~
    fn floor_log10(&self) -> u32; //note: u32 return type to allow BigInt types to implement. 10^(2^32) is 4 billion digits
}

/// Returns `true` if the number is a power of 10.
#[inline]
pub fn is_power_of_ten<T: Power10>(x: T) -> bool {
    x.is_power_of_ten()
}

/// Returns the base 10 logarithm value, truncated down.
#[inline]
pub fn floor_log10<T: Power10>(x: T) -> u32 {
    x.floor_log10()
}

// Implementation note: the is_power_of_ten algorithm for u16/u32 is based on a
// perfect hash setup with very simple hash functions. These hash functions only use 32-bit
// operations for portable-speed.
// This approach is slightly better than leading_zeros() (which is used u64 and fast logarithms)
static POWER10_HASH_U16: [u32;8] = [1, 10, 10000, 0, 100, 1000, 0, 0];
static POWER10_HASH_U32: [u32;16] = [10000, 1, 10000000, 0, 100, 0, 100000, 100000000, 1000, 0, 10, 1000000000, 0, 1000000, 0, 0];
static POWER10_LZ_U64: [u64; 65] = [
    10000000000000000000, <u64>::max_value(), <u64>::max_value(), <u64>::max_value(),
    1000000000000000000, <u64>::max_value(), <u64>::max_value(),
    100000000000000000, <u64>::max_value(), <u64>::max_value(),
    10000000000000000, <u64>::max_value(), <u64>::max_value(), <u64>::max_value(),
    1000000000000000, <u64>::max_value(), <u64>::max_value(),
    100000000000000, <u64>::max_value(), <u64>::max_value(),
    10000000000000, <u64>::max_value(), <u64>::max_value(), <u64>::max_value(),
    1000000000000, <u64>::max_value(), <u64>::max_value(),
    100000000000, <u64>::max_value(), <u64>::max_value(),
    10000000000, <u64>::max_value(), <u64>::max_value(), <u64>::max_value(),
    1000000000, <u64>::max_value(), <u64>::max_value(),
    100000000, <u64>::max_value(), <u64>::max_value(),
    10000000, <u64>::max_value(), <u64>::max_value(), <u64>::max_value(),
    1000000, <u64>::max_value(), <u64>::max_value(),
    100000, <u64>::max_value(), <u64>::max_value(),
    10000, <u64>::max_value(), <u64>::max_value(), <u64>::max_value(),
    1000, <u64>::max_value(), <u64>::max_value(),
    100, <u64>::max_value(), <u64>::max_value(),
    10, <u64>::max_value(), <u64>::max_value(),
    1, 1];

// implementation note: reverse search is a bit faster than hash lookup for u8
#[inline]
fn is_pow10_u8(v: u8) -> bool {
    if v >= 100 { return v == 100; }
    if v >= 10 { return v == 10; }
    v == 1
}

// implementation note: at least on x86-64, 32bit ops are far faster than 16 bit ones, even ==
#[inline]
fn is_pow10_u16(v: u16) -> bool {
    v as u32 == POWER10_HASH_U16[((v as u32 >> 3) & 7) as usize]
}

#[inline]
fn is_pow10_u32(v: u32) -> bool {
    let hash = v ^ (v >> 14);
    v == POWER10_HASH_U32[(hash & 15) as usize]
}

#[inline]
fn is_pow10_u64(v: u64) -> bool {
    v == POWER10_LZ_U64[(v.leading_zeros() & 63) as usize] // & 63 may look redundant, but it prevents a range check
}

#[cfg(target_pointer_width = "64")]
#[inline]
fn is_pow10_usize(v: usize) -> bool {
    is_pow10_u64(v as u64)
}

#[cfg(target_pointer_width = "32")]
#[inline]
fn is_pow10_usize(v: usize) -> bool {
    is_pow10_u32(v as u32)
}

#[inline]
fn floor_log10_u8(v: u8) -> u32 {
    if v >= 100 { return 2; }
    if v >= 10 { return 1; }
    0
}

#[inline]
fn floor_log10_u16(v: u16) -> u32 {
    floor_log10_u32(v as u32)
}

static POWER10_DIGITS_U32: [(u32, u32); 33] = [
    (8, 1_000_000_000), (8, 1_000_000_000),
    (8, 1_000_000_000), (8, 1000000000), (8, 1000000000),
    (7, 100000000), (7, 100000000), (7, 100000000),
    (6, 10000000), (6, 10000000), (6, 10000000), (6, 10000000),
    (5, 1000000), (5, 1000000), (5, 1000000),
    (4, 100000), (4, 100000), (4, 100000),
    (3, 10000), (3, 10000), (3, 10000), (3, 10000),
    (2, 1000), (2, 1000), (2, 1000),
    (1, 100), (1, 100), (1, 100),
    (0, 10), (0, 10), (0, 10), (0, 10),
    (0, 1)];

static POWER10_DIGITS_U64: [(u32, u64); 65] = [
    (18, 10000000000000000000), (18, 10000000000000000000), (18, 10000000000000000000), (18, 10000000000000000000),
    (17, 1000000000000000000), (17, 1000000000000000000), (17, 1000000000000000000),
    (16, 100000000000000000), (16, 100000000000000000), (16, 100000000000000000),
    (15, 10000000000000000), (15, 10000000000000000), (15, 10000000000000000), (15, 10000000000000000),
    (14, 1000000000000000), (14, 1000000000000000), (14, 1000000000000000),
    (13, 100000000000000), (13, 100000000000000), (13, 100000000000000),
    (12, 10000000000000), (12, 10000000000000), (12, 10000000000000), (12, 10000000000000),
    (11, 1000000000000), (11, 1000000000000), (11, 1000000000000),
    (10, 100000000000), (10, 100000000000), (10, 100000000000),
    (9, 10000000000), (9, 10000000000), (9, 10000000000), (9, 10000000000),
    (8, 1000000000), (8, 1000000000), (8, 1000000000),
    (7, 100000000), (7, 100000000), (7, 100000000),
    (6, 10000000), (6, 10000000), (6, 10000000), (6, 10000000),
    (5, 1000000), (5, 1000000), (5, 1000000),
    (4, 100000), (4, 100000), (4, 100000),
    (3, 10000), (3, 10000), (3, 10000), (3, 10000),
    (2, 1000), (2, 1000), (2, 1000),
    (1, 100), (1, 100), (1, 100),
    (0, 10), (0, 10), (0, 10), (0, 10),
    (0, 1)];

#[inline]
fn floor_log10_u32(v: u32) -> u32 {
    let lz = v.leading_zeros();
    let (digits, pow10) = POWER10_DIGITS_U32[lz as usize];
    digits + ((v >= pow10) as u32)
}

#[inline]
fn floor_log10_u64(v: u64) -> u32 {
    let lz = v.leading_zeros();
    let (digits, pow10) = POWER10_DIGITS_U64[lz as usize];
    digits + ((v >= pow10) as u32)
}

#[cfg(target_pointer_width = "64")]
#[inline]
fn floor_log10_usize(v: usize) -> u32 {
    floor_log10_u64(v as u64)
}

#[cfg(target_pointer_width = "32")]
#[inline]
fn floor_log10_usize(v: usize) -> u32 {
    floor_log10_u32(v as u32)
}

macro_rules! hide_u128 {
    ($T:ty) => {
        static POWER10_HASH_U128: [$T; 64] = [100000000000000000000000000000000000, 0, 100000000000000000000000000000000,
            0, 1000, 0, 0, 0, 0,
            1000000000000000000000000000000000000, 1000000000, 0, 100000000000000, 100, 0, 0, 0, 100000, 0, 0,
            10000000000000, 100000000000, 10000000000000000000, 0, 0, 10000000000000000000000000000000000,
            100000000, 0, 1000000000000000000000000000000000, 1000000000000, 0, 100000000000000000000000000000000000000,
            10000000000000000, 100000000000000000000000000, 0, 10000000000000000000000000000000000000,
            1000000000000000000, 1, 10000000000000000000000000, 1000000000000000000000000, 100000000000000000000000000000,
            10000000, 10000000000000000000000000000, 0, 1000000000000000000000000000, 100000000000000000, 10000,
            0, 1000000, 1000000000000000000000000000000, 0, 100000000000000000000, 10, 0, 10000000000,
            10000000000000000000000, 0, 0, 10000000000000000000000000000000, 1000000000000000000000, 0,
            100000000000000000000000, 1000000000000000, 0];

        #[inline]
        pub fn is_pow10_u128(v: $T) -> bool {
            let mut hash: u32 = v as u32 | (((v as u64) >> 32) as u32);
            hash = hash.wrapping_mul(1249991743) >> 25;
            v == POWER10_HASH_U128[(hash & 63) as usize]
        }
        
        static POWER10_DIGITS_U128: [(u32, u128); 129] = [
            (37, 100000000000000000000000000000000000000),
            (37, 100000000000000000000000000000000000000), (37, 100000000000000000000000000000000000000), (37, 100000000000000000000000000000000000000), (37, 100000000000000000000000000000000000000),
            (36, 10000000000000000000000000000000000000), (36, 10000000000000000000000000000000000000), (36, 10000000000000000000000000000000000000),
            (35, 1000000000000000000000000000000000000), (35, 1000000000000000000000000000000000000), (35, 1000000000000000000000000000000000000),
            (34, 100000000000000000000000000000000000), (34, 100000000000000000000000000000000000), (34, 100000000000000000000000000000000000), (34, 100000000000000000000000000000000000),
            (33, 10000000000000000000000000000000000), (33, 10000000000000000000000000000000000), (33, 10000000000000000000000000000000000),
            (32, 1000000000000000000000000000000000), (32, 1000000000000000000000000000000000), (32, 1000000000000000000000000000000000),
            (31, 100000000000000000000000000000000), (31, 100000000000000000000000000000000), (31, 100000000000000000000000000000000), (31, 100000000000000000000000000000000),
            (30, 10000000000000000000000000000000), (30, 10000000000000000000000000000000), (30, 10000000000000000000000000000000),
            (29, 1000000000000000000000000000000), (29, 1000000000000000000000000000000), (29, 1000000000000000000000000000000),
            (28, 100000000000000000000000000000), (28, 100000000000000000000000000000), (28, 100000000000000000000000000000),
            (27, 10000000000000000000000000000), (27, 10000000000000000000000000000), (27, 10000000000000000000000000000), (27, 10000000000000000000000000000),
            (26, 1000000000000000000000000000), (26, 1000000000000000000000000000), (26, 1000000000000000000000000000),
            (25, 100000000000000000000000000), (25, 100000000000000000000000000), (25, 100000000000000000000000000),
            (24, 10000000000000000000000000), (24, 10000000000000000000000000), (24, 10000000000000000000000000), (24, 10000000000000000000000000),
            (23, 1000000000000000000000000), (23, 1000000000000000000000000), (23, 1000000000000000000000000),
            (22, 100000000000000000000000), (22, 100000000000000000000000), (22, 100000000000000000000000),
            (21, 10000000000000000000000), (21, 10000000000000000000000), (21, 10000000000000000000000), (21, 10000000000000000000000),
            (20, 1000000000000000000000), (20, 1000000000000000000000), (20, 1000000000000000000000),
            (19, 100000000000000000000), (19, 100000000000000000000), (19, 100000000000000000000),
            (18, 10000000000000000000), (18, 10000000000000000000), (18, 10000000000000000000), (18, 10000000000000000000),
            (17, 1000000000000000000), (17, 1000000000000000000), (17, 1000000000000000000),
            (16, 100000000000000000), (16, 100000000000000000), (16, 100000000000000000),
            (15, 10000000000000000), (15, 10000000000000000), (15, 10000000000000000), (15, 10000000000000000),
            (14, 1000000000000000), (14, 1000000000000000), (14, 1000000000000000),
            (13, 100000000000000), (13, 100000000000000), (13, 100000000000000),
            (12, 10000000000000), (12, 10000000000000), (12, 10000000000000), (12, 10000000000000),
            (11, 1000000000000), (11, 1000000000000), (11, 1000000000000),
            (10, 100000000000), (10, 100000000000), (10, 100000000000),
            (9, 10000000000), (9, 10000000000), (9, 10000000000), (9, 10000000000),
            (8, 1000000000), (8, 1000000000), (8, 1000000000),
            (7, 100000000), (7, 100000000), (7, 100000000),
            (6, 10000000), (6, 10000000), (6, 10000000), (6, 10000000),
            (5, 1000000), (5, 1000000), (5, 1000000),
            (4, 100000), (4, 100000), (4, 100000),
            (3, 10000), (3, 10000), (3, 10000), (3, 10000),
            (2, 1000), (2, 1000), (2, 1000),
            (1, 100), (1, 100), (1, 100),
            (0, 10), (0, 10), (0, 10), (0, 10),
            (0, 1)];

        #[inline]
        fn floor_log10_u128(v: $T) -> u32 {
            let lz = v.leading_zeros();
            let (digits, pow10) = POWER10_DIGITS_U128[lz as usize];
            digits + ((v >= pow10) as u32)
        }
    }
}

#[cfg(has_i128)]
hide_u128!(u128);

macro_rules! unsigned_power10 {
    ($T:ty, $pow_fn: ident, $log_fn: ident) => {
        impl Power10 for $T {
            #[inline]
            fn is_power_of_ten(&self) -> bool {
                $pow_fn(*self)
            }

            #[inline]
            fn floor_log10(&self) -> u32 {
                $log_fn(*self)
            }
        }
    };
}

unsigned_power10!(u8, is_pow10_u8, floor_log10_u8); //https://github.com/rust-lang/rust/issues/29599
unsigned_power10!(u16, is_pow10_u16, floor_log10_u16);
unsigned_power10!(u32, is_pow10_u32, floor_log10_u32);
unsigned_power10!(u64, is_pow10_u64, floor_log10_u64);
#[cfg(has_i128)]
unsigned_power10!(u128, is_pow10_u128, floor_log10_u128);
unsigned_power10!(usize, is_pow10_usize, floor_log10_usize);





